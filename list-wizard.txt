
 ‚ñê‚ñõ‚ñà‚ñà‚ñà‚ñú‚ñå   Claude Code v2.0.49
‚ñù‚ñú‚ñà‚ñà‚ñà‚ñà‚ñà‚ñõ‚ñò  Sonnet 4.5 ¬∑ Claude Max
  ‚ñò‚ñò ‚ñù‚ñù    ~/dev/the-greatest

> currently we use items_json on @web-app/app/models/list.rb to manage and 
help lookup data when adding a new list. see 
@docs/lib/services/lists/music/songs/items_json_importer.md 
@web-app/app/lib/services/lists/music/songs/items_json_importer.rb 
@web-app/docs/lib/services/lists/music/songs/items_json_enricher.md 
@docs/todos/completed/053-items-json-viewer-resource-tool.md 
@docs/todos/completed/065-items-json-viewer-songs.md I am wondering if this 
is the best approach. Right now my workflow is to: parse the list using AI, 
which populates items_json. then i enrich items_json, then i run the AI task
 that validates the matches in items_json. then i copy and paste the json 
into an editor and go through all the invalid matches and manually update 
them, then i edit the list, and paste in the updated items_json and save, 
then import the list-items from the items_json which creates albums/songs, 
and creates all the items_json. I would like to improve this process so it 
can all be done online, and editing a big json blob inline is messy. I am 
thinking if i should just initially populate list_items and use the metadata
 field on a list_item to store the data that's in items_json, then allow 
users to verify and fix un-verified list_items right from the UI... the 
other approach i used on my old books site, The Greatest Books, was had a 
seperate pending_list_items relationship, then i would get the 
pending_list_items looking great, and then run a process that populated 
list_items from pending_list_items, but that seems a bit weird since a 
pending_list_item is basically the same as list_item. what do you think? see
 @AGENTS.md @docs/dev-core-values.md and use sub-agents to help you research
 the current process. @docs/sub-agents.md we should document this in a new 
spec according to @docs/todo-guide.md the old items_json specific code is 
build for AVO so this new process I want to build in the new admin 
functionality. I also want to make it a fancy multi-step wizard so I can 
hand this off to non coders to add lists 

‚óè I'll help you analyze the current process and design a better workflow.
  Let me first research the current implementation to understand all the
  moving parts.

‚óè codebase-analyzer(Analyze items_json workflow)
  ‚éø ¬†Done (34 tool uses ¬∑ 86.4k tokens ¬∑ 4m 42s)                           

‚óè codebase-pattern-finder(Find list_item patterns)
  ‚éø ¬†Done (35 tool uses ¬∑ 48.7k tokens ¬∑ 2m 36s)                           

‚óè codebase-locator(Find custom admin code)
  ‚éø ¬†Done (64 tool uses ¬∑ 44.3k tokens ¬∑ 2m 58s)                           

‚óè Now let me create a comprehensive task specification for this improvement
  based on the research:

‚óè Based on my analysis, here's my recommendation:

  Recommended Approach: Use list_items.metadata with Verification Workflow 
  ‚úÖ

  After thoroughly analyzing your current implementation and workflow pain
  points, I recommend using the existing list_items table with the metadata 
  JSONB field and verified boolean rather than a separate pending_list_items
   table. Here's why:

  Why This is Better Than pending_list_items:

  1. Already Partially Implemented: Your ListItem model already has metadata
   and verified fields (added in migration
  20250828032452_refactor_list_item_for_unverified_items.rb), supporting
  optional polymorphic associations
  2. Simpler Data Model: No need for a separate table, migration to move
  data, or complex synchronization logic
  3. Natural Progression: verified: false ‚Üí verified: true is clearer than
  pending_list_items ‚Üí list_items transfer
  4. Audit Trail: Can keep unverified items visible in admin for historical
  tracking rather than deleting pending records
  5. Consistent Patterns: Your existing admin UI already handles list_items
  with metadata (seen in EditListItemModalComponent)

  Current Pain Points You Want to Solve:

  From your workflow description, the main issues are:

  1. Manual JSON editing outside the app - Need inline editing UI
  2. No way to fix individual invalid matches - Need per-item actions
  3. Copy-paste between console and editor - Need browser-based workflow
  4. Risk of JSON syntax errors - Need form-based editing
  5. Non-technical users can't manage lists - Need friendly wizard UI

  Proposed New Workflow:

  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  STAGE 1: AI Parsing ‚Üí Populate Unverified list_items       ‚îÇ
  ‚îÇ  - Parse HTML with AI (existing)                             ‚îÇ
  ‚îÇ  - Create list_items with:                                   ‚îÇ
  ‚îÇ    * listable_id: null                                       ‚îÇ
  ‚îÇ    * listable_type: "Music::Song" (expected type)           ‚îÇ
  ‚îÇ    * metadata: {rank, title, artists, album, year}          ‚îÇ
  ‚îÇ    * verified: false                                         ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  STAGE 2: Enrichment ‚Üí Add MusicBrainz data to metadata     ‚îÇ
  ‚îÇ  - For each unverified list_item:                            ‚îÇ
  ‚îÇ    * Search OpenSearch/MusicBrainz                           ‚îÇ
  ‚îÇ    * Update metadata with enrichment data:                   ‚îÇ
  ‚îÇ      {                                                        ‚îÇ
  ‚îÇ        ...original fields,                                   ‚îÇ
  ‚îÇ        mb_recording_id: "...",                               ‚îÇ
  ‚îÇ        song_id: 123 (if found),                             ‚îÇ
  ‚îÇ        opensearch_match: true/false                          ‚îÇ
  ‚îÇ      }                                                        ‚îÇ
  ‚îÇ    * Still verified: false                                   ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  STAGE 3: AI Validation ‚Üí Flag invalid matches              ‚îÇ
  ‚îÇ  - Run AI validation on enriched metadata                    ‚îÇ
  ‚îÇ  - Update metadata with:                                     ‚îÇ
  ‚îÇ    * ai_match_invalid: true (for bad matches)               ‚îÇ
  ‚îÇ    * ai_validation_reason: "Live vs Studio" (optional)      ‚îÇ
  ‚îÇ  - Still verified: false                                     ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  STAGE 4: WIZARD UI ‚Üí Review & Fix in Browser               ‚îÇ
  ‚îÇ                                                               ‚îÇ
  ‚îÇ  Multi-Step Wizard Interface:                                ‚îÇ
  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
  ‚îÇ  ‚îÇ Step 1: Review Enriched Items                        ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ [‚úì Valid] Song 1 - Artist 1 (75 items)             ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ [‚ö† Invalid] Song 2 - Wrong Artist (5 items)        ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ [‚úó Missing] Song 3 - Not Found (3 items)           ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ                                                       ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ Actions per item:                                    ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ ‚Ä¢ ‚úì Verify ‚Üí Sets listable_id, verified: true       ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ ‚Ä¢ ‚úó Skip ‚Üí Deletes list_item                        ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ ‚Ä¢ ‚úèÔ∏è Edit ‚Üí Inline form to fix metadata             ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ ‚Ä¢ üîç Re-search ‚Üí Run enrichment again                ‚îÇ   ‚îÇ
  ‚îÇ  ‚îÇ ‚Ä¢ üéØ Manual Link ‚Üí Autocomplete to pick song         ‚îÇ   ‚îÇ
  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
  ‚îÇ                                                               ‚îÇ
  ‚îÇ  Step 2: Import Missing Songs (optional)                     ‚îÇ
  ‚îÇ  - For items flagged as "not found"                          ‚îÇ
  ‚îÇ  - Show list of songs to import from MusicBrainz            ‚îÇ
  ‚îÇ  - Checkbox to select which to import                        ‚îÇ
  ‚îÇ  - Background job imports selected songs                     ‚îÇ
  ‚îÇ                                                               ‚îÇ
  ‚îÇ  Step 3: Final Review & Verify                               ‚îÇ
  ‚îÇ  - Show summary: 75 verified, 3 skipped, 5 need attention   ‚îÇ
  ‚îÇ  - Bulk actions: "Verify all valid", "Skip all invalid"     ‚îÇ
  ‚îÇ  - Final button: "Complete List" ‚Üí marks all as verified     ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  STAGE 5: Verification ‚Üí Link songs & mark verified         ‚îÇ
  ‚îÇ  - For each verified list_item:                              ‚îÇ
  ‚îÇ    * Set listable_id to matched song                        ‚îÇ
  ‚îÇ    * Set verified: true                                      ‚îÇ
  ‚îÇ    * Keep metadata for audit trail                          ‚îÇ
  ‚îÇ  - Import missing songs if needed                            ‚îÇ
  ‚îÇ  - List is now complete!                                     ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

  Key Differences from Current Workflow:

  | Current (items_json)           | Proposed (list_items.metadata) |
  |--------------------------------|--------------------------------|
  | All data in single JSONB field | Each item is a database row    |
  | Copy-paste JSON blob           | Per-item actions in UI         |
  | External text editor           | Browser-based wizard           |
  | All-or-nothing import          | Progressive verification       |
  | Re-run entire pipeline         | Fix individual items           |
  | No UI for fixing issues        | Inline editing forms           |
  | Technical users only           | Non-technical friendly         |

  Technical Implementation Plan:

  I'm creating a detailed specification file now. Here are the key
  components needed:

  1. Wizard Controller (Admin::Music::Songs::ListWizardController)
    - Multi-step form flow (similar to e-commerce checkouts)
    - Turbo Frame navigation between steps
    - Progress indicator
  2. Wizard Views (Turbo Frame steps)
    - step_1_review.html.erb - Show all items with status badges
    - step_2_fix_items.html.erb - Inline editing for invalid items
    - step_3_import.html.erb - Select songs to import
    - step_4_summary.html.erb - Final review before completion
  3. Stimulus Controllers
    - list_wizard_controller.js - Step navigation
    - list_item_editor_controller.js - Inline item editing
    - bulk_actions_controller.js - Select all, verify all, etc.
  4. Background Jobs
    - Modify existing enrichment jobs to update list_items.metadata instead
  of items_json
    - Keep validation jobs similar but operating on list_items
  5. Service Layer
    - Services::Lists::Music::Songs::ItemVerifier - Verifies items and links
   songs
    - Services::Lists::Music::Songs::BulkVerifier - Batch verification
    - Refactor existing importers to work with list_items

  Let me create the full specification document now:

‚óè Write(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Wrote 1864 lines to docs/todos/086-list-wizard-verification-workflow.m

     # [086] - List Wizard Verification Workflow
     ## Status
     - **Status**: Planned
     - **Priority**: High
     - **Created**: 2025-01-19
     - **Started**: Not started
     - **Completed**: Not completed
     - **Developer**: AI + Human
     ‚Ä¶ +1854 lines (ctrl+o to expand)

‚óè Summary

  I've completed a comprehensive analysis of your current workflow and
  created a detailed specification for the new list wizard verification
  workflow. Here's what I recommend:

  ‚úÖ Recommendation: Use list_items.metadata with Verification Workflow

  Why this approach is better than pending_list_items:

  1. Already 50% implemented - Your ListItem model already has metadata
  JSONB field, verified boolean, and optional polymorphic association
  2. Simpler data model - No second table, no data migration between tables,
   no synchronization issues
  3. Natural progression - verified: false ‚Üí verified: true is clearer than
  moving between tables
  4. Audit trail - Can keep unverified items for historical tracking
  5. Your old The Greatest Books approach with pending_list_items was 
  essentially the same thing, just in two tables instead of one

  Key Improvements Over Current Workflow:

  | Current Pain Point                               | New Solution
                                                          |
  |--------------------------------------------------|----------------------
  --------------------------------------------------------|
  | Copy-paste JSON editing in external editor       | Browser-based
  multi-step wizard UI                                           |
  | No way to fix individual items                   | Per-item actions:
  verify, skip, edit, re-search, manual link, import, delete |
  | Technical users only (Rails console required)    | Non-technical
  friendly wizard interface                                      |
  | All-or-nothing import                            | Progressive
  verification, fix items individually                             |
  | Context switching (Avo ‚Üí console ‚Üí editor ‚Üí Avo) | Entire workflow in
  browser                                                   |
  | JSON syntax errors                               | Form-based editing
  with validation                                           |

  New Workflow at a Glance:

  Step 1: Parse HTML ‚Üí Create unverified list_items with metadata
  Step 2: Enrich ‚Üí Update metadata with OpenSearch/MusicBrainz data
  Step 3: Validate ‚Üí AI flags invalid matches in metadata
  Step 4: Review & Fix (üåüTHE KEY STEPüåü) ‚Üí Interactive table with:
    - ‚úì Verify button (link song, mark verified)
    - ‚úó Skip button (mark as skipped)
    - ‚úèÔ∏è Edit button (inline metadata editing)
    - üîç Re-search button (re-run enrichment)
    - üéØ Manual Link button (autocomplete to pick song)
    - ‚ûï Import button (queue for MusicBrainz import)
    - üóëÔ∏è Delete button (remove item)
    - Bulk actions: Verify all valid, Skip all invalid, Delete all missing
  Step 5: Import & Complete ‚Üí Import missing songs, finalize verifications

  Implementation Estimate:

  14 days total broken into phases:
  - Phase 1: Database & Models (1 day)
  - Phase 2: Service Layer (2 days)
  - Phase 3: Background Jobs (1 day)
  - Phase 4: Controllers (2 days)
  - Phase 5: Views & Components (3 days) - Most complex
  - Phase 6: Stimulus Controllers (1 day)
  - Phase 7: Integration & Testing (2 days)
  - Phase 8: Migration from items_json (1 day)
  - Phase 9: Documentation & Cleanup (1 day)

  Next Steps:

  The full specification is now available at:
  docs/todos/086-list-wizard-verification-workflow.md

  This 600+ line specification includes:
  - ‚úÖ Complete database schema changes
  - ‚úÖ All controller actions with example code
  - ‚úÖ All view templates with DaisyUI components
  - ‚úÖ All Stimulus controllers for interactivity
  - ‚úÖ All background jobs
  - ‚úÖ All service objects
  - ‚úÖ Routes configuration
  - ‚úÖ Testing approach
  - ‚úÖ Performance considerations
  - ‚úÖ Security considerations
  - ‚úÖ 9 implementation phases with task breakdowns

  The specification follows your docs/todo-guide.md format with contracts,
  acceptance criteria, and implementation phases. It's ready to be handed
  off to an AI agent (or yourself) for implementation.

  Would you like me to start implementing Phase 1 (Database & Models) to get
   the ball rolling?

> how do you think we should handle when to go to the next step in the 
wizard? since these all happen in background jobs it seems like we need to 
track the status of the job and block from going to the next step. i am just
 thinking out loud. we have not used web sockets yet but i guess we could? 
let's just think about this. we would need to store data in redis or on the 
list.metadata field and then have the sidekiq job update that 

‚óè codebase-pattern-finder(Find background job patterns)
  ‚éø ¬†Done (58 tool uses ¬∑ 58.8k tokens ¬∑ 2m 54s)                           

> I think my computer crashed with the last text i sent. how do you think we
 should handle when to go to the next step in the wizard? since these all 
happen in background
jobs it seems like we need to track the status of the job and block from 
going to the next step. i am just thinking
out loud. we have not used web sockets yet but i guess we could? let's just 
think about this. we would need to store
 data in redis or on the list.metadata field and then have the sidekiq job 
update that 

‚óè Great question! This is a critical design decision. Let me think through
  the options based on what I found in your codebase.

  Current State of Your Codebase

  From my research, you currently have:
  - ‚úÖ Fire-and-forget jobs (no status tracking)
  - ‚úÖ JSONB metadata fields on List and ListItem models
  - ‚úÖ Redis configured for Sidekiq only
  - ‚ùå No Action Cable / WebSockets
  - ‚ùå No polling patterns
  - ‚ùå No job status tracking

  Options for Wizard Step Progression

  Option 1: Simple Polling with Database Status (RECOMMENDED)

  Store job status in the database and poll for completion.

  How it works:

  # Add to list_wizard_states table
  create_table :list_wizard_states do |t|
    t.references :list, null: false
    t.integer :current_step, default: 0
    t.jsonb :step_data, default: {}

    # Job tracking fields
    t.string :current_job_status  # 'idle', 'running', 'completed', 'failed'
    t.text :current_job_error
    t.integer :current_job_progress  # For progress bars (0-100)
    t.jsonb :current_job_metadata    # For detailed progress
  end

  Job updates status:

  class Music::Songs::WizardEnrichListItemsJob
    def perform(list_id)
      list = Music::Songs::List.find(list_id)
      wizard_state = list.list_wizard_state

      # Mark as running
      wizard_state.update!(
        current_job_status: 'running',
        current_job_progress: 0
      )

      items = list.list_items.unverified
      total = items.count

      items.each_with_index do |item, index|
        Services::Lists::Music::Songs::ItemEnricher.call(list_item: item)

        # Update progress every 10 items or on last item
        if (index + 1) % 10 == 0 || index == total - 1
          wizard_state.update!(
            current_job_progress: ((index + 1).to_f / total * 100).round
          )
        end
      end

      # Mark as completed
      wizard_state.update!(
        current_job_status: 'completed',
        current_job_progress: 100
      )
    rescue => e
      wizard_state.update!(
        current_job_status: 'failed',
        current_job_error: e.message
      )
      raise
    end
  end

  JavaScript polling (simple):

  // app/javascript/controllers/wizard_step_controller.js
  import { Controller } from "@hotwired/stimulus"

  export default class extends Controller {
    static values = {
      listId: Number,
      stepName: String,
      pollInterval: { type: Number, default: 2000 } // 2 seconds
    }

    connect() {
      this.startPolling()
    }

    disconnect() {
      this.stopPolling()
    }

    startPolling() {
      this.poll()
    }

    stopPolling() {
      if (this.pollTimer) {
        clearInterval(this.pollTimer)
      }
    }

    poll() {
      this.pollTimer = setInterval(() => {
        this.checkJobStatus()
      }, this.pollIntervalValue)
    }

    async checkJobStatus() {
      const response = await fetch(
        `/admin/music/songs/lists/${this.listIdValue}/wizard/step/${this.ste
  pNameValue}/status`
      )
      const data = await response.json()

      // Update progress bar
      this.updateProgress(data.progress)

      // If completed, enable next button and stop polling
      if (data.status === 'completed') {
        this.stopPolling()
        this.enableNextButton()
      }

      // If failed, show error and stop polling
      if (data.status === 'failed') {
        this.stopPolling()
        this.showError(data.error)
      }
    }

    updateProgress(percent) {
      const progressBar = this.element.querySelector('[data-progress-bar]')
      if (progressBar) {
        progressBar.style.width = `${percent}%`
        progressBar.textContent = `${percent}%`
      }
    }

    enableNextButton() {
      const nextButton = this.element.querySelector('[data-next-button]')
      if (nextButton) {
        nextButton.disabled = false
        nextButton.classList.remove('btn-disabled')
      }
    }

    showError(error) {
      // Update UI with error message
    }
  }

  Status endpoint:

  # app/controllers/admin/music/songs/list_wizard_controller.rb
  def step_status
    wizard_state = @list.list_wizard_state

    render json: {
      status: wizard_state.current_job_status,
      progress: wizard_state.current_job_progress,
      error: wizard_state.current_job_error,
      metadata: wizard_state.current_job_metadata
    }
  end

  Pros:
  - ‚úÖ Simple to implement
  - ‚úÖ No new infrastructure (no WebSockets needed)
  - ‚úÖ Works with existing patterns
  - ‚úÖ Progress stored in database (can resume if browser closes)
  - ‚úÖ Works great for your use case (not high-frequency updates)

  Cons:
  - ‚ùå Slight delay in updates (2 second intervals)
  - ‚ùå Extra database queries during polling
  - ‚ùå Not "truly" real-time

  ---
  Option 2: Turbo Streams with Polling (Hybrid)

  Use Turbo Streams for updates but trigger them via polling.

  How it works:

  # Controller returns turbo stream instead of JSON
  def step_status
    wizard_state = @list.list_wizard_state

    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: [
          turbo_stream.replace(
            "wizard_progress",
            partial: "admin/music/songs/list_wizard/progress",
            locals: { progress: wizard_state.current_job_progress }
          ),
          turbo_stream.replace(
            "wizard_status",
            partial: "admin/music/songs/list_wizard/status",
            locals: { status: wizard_state.current_job_status }
          )
        ]
      end
    end
  end

  JavaScript fetches Turbo Stream:

  async checkJobStatus() {
    const response = await fetch(
      `/admin/music/songs/lists/${this.listIdValue}/wizard/step/${this.stepN
  ameValue}/status`,
      {
        headers: {
          'Accept': 'text/vnd.turbo-stream.html'
        }
      }
    )

    const html = await response.text()
    Turbo.renderStreamMessage(html)

    // Check if completed (you'd need to add this to the response)
    // or poll a separate JSON endpoint just for status
  }

  Pros:
  - ‚úÖ Turbo handles DOM updates automatically
  - ‚úÖ Can update multiple parts of UI at once
  - ‚úÖ Still uses database storage

  Cons:
  - ‚ùå Slightly more complex than Option 1
  - ‚ùå Still polling-based (not real-time)

  ---
  Option 3: Action Cable / WebSockets (Overkill for MVP)

  Real-time updates via WebSockets.

  How it works:

  # app/channels/wizard_progress_channel.rb
  class WizardProgressChannel < ApplicationCable::Channel
    def subscribed
      stream_from "wizard_progress_#{params[:list_id]}"
    end
  end

  # In job:
  ActionCable.server.broadcast(
    "wizard_progress_#{list_id}",
    {
      status: 'running',
      progress: 45,
      message: "Enriched 45/100 items"
    }
  )

  Pros:
  - ‚úÖ True real-time updates
  - ‚úÖ No polling overhead
  - ‚úÖ Scalable for many concurrent users

  Cons:
  - ‚ùå Requires Action Cable setup (new infrastructure)
  - ‚ùå Requires Redis for pub/sub
  - ‚ùå More complex to implement
  - ‚ùå Overkill for your use case (wizard used by admins, not
  high-frequency)

  ---
  Option 4: Optimistic UI with Step Validation (No Polling)

  Allow user to proceed to next step immediately, but validate they can't
  advance if job hasn't completed.

  How it works:

  # Wizard controller
  def show_step
    @step_name = params[:step]

    # Validate can access this step
    unless can_access_step?(@step_name)
      redirect_to wizard_step_path(step: required_step),
        alert: "Please complete the #{required_step} step first"
      return
    end

    # Render step...
  end

  private

  def can_access_step?(step_name)
    wizard_state = @list.list_wizard_state

    case step_name
    when "enrich"
      # Can only access if parse completed
      @list.list_items.unverified.any?
    when "validate"
      # Can only access if enrichment completed
      wizard_state.current_step >= 2
    when "review"
      # Can only access if validation completed
      wizard_state.current_step >= 3
    # etc.
    end
  end

  User flow:
  1. User clicks "Start Enrichment" ‚Üí Job enqueued
  2. "Next Step" button immediately enabled
  3. User clicks "Next Step"
  4. Server checks if enrichment done, redirects back if not

  Pros:
  - ‚úÖ No polling needed
  - ‚úÖ Simple implementation
  - ‚úÖ User can navigate away and come back

  Cons:
  - ‚ùå Confusing UX (button enabled but step not ready)
  - ‚ùå No progress visibility
  - ‚ùå User has to keep clicking "Next" to check

  ---
  My Recommendation: Option 1 (Simple Polling)

  Here's why Option 1 (Simple Polling with Database Status) is best for your
   wizard:

  Why it fits your use case:

  1. Low Frequency Updates: Enrichment takes 1-2 seconds per song. For a
  100-song list, that's 2-3 minutes total. Polling every 2 seconds is
  perfect.
  2. Admin-Only Feature: This wizard is used by admins/editors, not
  end-users. You're not talking about thousands of concurrent wizards.
  3. Simple Implementation: No new infrastructure needed. Just add columns
  to list_wizard_states table.
  4. Resumable: If user closes browser, progress is in database. They can
  come back and see where it's at.
  5. Matches Your Patterns: Your codebase already uses:
    - Database-backed state
    - Turbo Streams for updates
    - No WebSockets/Action Cable
  6. Progressive Enhancement: Start with polling, upgrade to Action Cable
  later if needed.

  Suggested Implementation:

  # Migration
  class AddJobTrackingToListWizardStates < ActiveRecord::Migration[8.0]
    def change
      add_column :list_wizard_states, :current_job_status, :string, default:
   'idle'
      add_column :list_wizard_states, :current_job_error, :text
      add_column :list_wizard_states, :current_job_progress, :integer,
  default: 0
      add_column :list_wizard_states, :current_job_metadata, :jsonb,
  default: {}

      add_index :list_wizard_states, [:list_id, :current_job_status]
    end
  end

  View with progress:

  <!-- app/views/admin/music/songs/list_wizard/_enrich.html.erb -->
  <div data-controller="wizard-step" 
       data-wizard-step-list-id-value="<%= @list.id %>"
       data-wizard-step-step-name-value="enrich">

    <h2>Enriching Items</h2>

    <div id="wizard_progress">
      <%= render "wizard_progress", progress:
  @wizard_state.current_job_progress %>
    </div>

    <div id="wizard_status">
      <%= render "wizard_status", status: @wizard_state.current_job_status
  %>
    </div>

    <%= button_to "Next Step ‚Üí",
        advance_step_path(@list, step: "enrich"),
        method: :post,
        class: "btn btn-primary",
        disabled: @wizard_state.current_job_status != 'completed',
        data: { next_button: true } %>
  </div>

  What do you think?

  Should we go with Option 1 (polling)? Or do you see value in setting up
  Action Cable from the start (Option 3)?

  I'm leaning strongly toward Option 1 because:
  - It's the simplest
  - It matches your existing patterns
  - 2-second polling is perfectly fine for a 2-3 minute enrichment job
  - You can always upgrade to WebSockets later if needed

  What's your preference?

> let's just go for polling. i am not sure about having an entirely new 
table for tracking wizard status though. couldn't we just add another jsonb 
field on the list and store it all in json? we won't be querying on it, just
 displaying it. there won't be multiple people working on 1 list at the same
 time 

‚óè Read(web-app/app/models/list.rb)
  ‚éø ¬†Read 100 lines

‚óè Absolutely! That's a much simpler approach and totally makes sense given
  your constraints:

  ‚úÖ No querying needed - just display
  ‚úÖ Single user at a time - no concurrency issues
  ‚úÖ Simpler schema - no new table
  ‚úÖ Follows existing pattern - you already have items_json JSONB field

  Let me revise the approach:

  Revised: Wizard State in list.wizard_state JSONB Field

  Migration:

  class AddWizardStateToLists < ActiveRecord::Migration[8.0]
    def change
      add_column :lists, :wizard_state, :jsonb, default: {}
    end
  end

  Structure of wizard_state:

  {
    "current_step": 2,
    "started_at": "2025-01-19T10:30:00Z",
    "completed_at": null,

    "job_status": "running",
    "job_progress": 45,
    "job_error": null,
    "job_metadata": {
      "total_items": 100,
      "processed_items": 45,
      "enriched_count": 40,
      "failed_count": 5
    },

    "step_data": {
      "items_to_import": [123, 456, 789]
    }
  }

  Model helper methods:

  # app/models/list.rb
  class List < ApplicationRecord
    # Existing code...

    # Wizard state helpers
    def wizard_current_step
      wizard_state.fetch("current_step", 0)
    end

    def wizard_job_status
      wizard_state.fetch("job_status", "idle")
    end

    def wizard_job_progress
      wizard_state.fetch("job_progress", 0)
    end

    def wizard_job_error
      wizard_state.fetch("job_error", nil)
    end

    def wizard_job_metadata
      wizard_state.fetch("job_metadata", {})
    end

    def wizard_in_progress?
      wizard_state.fetch("started_at", nil).present? &&
        wizard_state.fetch("completed_at", nil).nil?
    end

    def update_wizard_job_status(status:, progress: nil, error: nil, 
  metadata: {})
      new_state = wizard_state.merge({
        "job_status" => status,
        "job_progress" => progress || wizard_job_progress,
        "job_error" => error,
        "job_metadata" => wizard_job_metadata.merge(metadata)
      })

      update!(wizard_state: new_state)
    end

    def reset_wizard!
      update!(wizard_state: {
        "current_step" => 0,
        "started_at" => Time.current.iso8601,
        "completed_at" => nil,
        "job_status" => "idle",
        "job_progress" => 0,
        "job_error" => nil,
        "job_metadata" => {},
        "step_data" => {}
      })
    end
  end

  Job updates:

  class Music::Songs::WizardEnrichListItemsJob
    include Sidekiq::Job

    def perform(list_id)
      list = Music::Songs::List.find(list_id)

      # Mark as running
      list.update_wizard_job_status(
        status: 'running',
        progress: 0,
        metadata: { started_at: Time.current.iso8601 }
      )

      items = list.list_items.unverified
      total = items.count
      enriched = 0
      failed = 0

      items.each_with_index do |item, index|
        result = Services::Lists::Music::Songs::ItemEnricher.call(list_item:
   item)

        if result.success?
          enriched += 1
        else
          failed += 1
        end

        # Update progress every 10 items
        if (index + 1) % 10 == 0 || index == total - 1
          progress = ((index + 1).to_f / total * 100).round

          list.update_wizard_job_status(
            status: 'running',
            progress: progress,
            metadata: {
              total_items: total,
              processed_items: index + 1,
              enriched_count: enriched,
              failed_count: failed
            }
          )
        end
      end

      # Mark as completed
      list.update_wizard_job_status(
        status: 'completed',
        progress: 100,
        metadata: {
          total_items: total,
          processed_items: total,
          enriched_count: enriched,
          failed_count: failed,
          completed_at: Time.current.iso8601
        }
      )

    rescue => e
      list.update_wizard_job_status(
        status: 'failed',
        error: e.message,
        metadata: {
          failed_at: Time.current.iso8601
        }
      )
      raise
    end
  end

  Controller status endpoint:

  # app/controllers/admin/music/songs/list_wizard_controller.rb
  def step_status
    render json: {
      status: @list.wizard_job_status,
      progress: @list.wizard_job_progress,
      error: @list.wizard_job_error,
      metadata: @list.wizard_job_metadata
    }
  end

  JavaScript stays the same:

  // app/javascript/controllers/wizard_step_controller.js
  async checkJobStatus() {
    const response = await fetch(
      `/admin/music/songs/lists/${this.listIdValue}/wizard/step/${this.stepN
  ameValue}/status`
    )
    const data = await response.json()

    this.updateProgress(data.progress, data.metadata)

    if (data.status === 'completed') {
      this.stopPolling()
      this.enableNextButton()
    }

    if (data.status === 'failed') {
      this.stopPolling()
      this.showError(data.error)
    }
  }

  updateProgress(percent, metadata) {
    const progressBar = this.element.querySelector('[data-progress-bar]')
    if (progressBar) {
      progressBar.style.width = `${percent}%`
    }

    const statusText = this.element.querySelector('[data-status-text]')
    if (statusText && metadata) {
      statusText.textContent =
        `Enriched ${metadata.processed_items || 0} of ${metadata.total_items
   || 0} items`
    }
  }

  Benefits of JSONB Approach:

  1. Simpler Schema - No new table, just one JSONB column
  2. No Joins - Everything on the List model already
  3. Flexible Structure - Easy to add new fields without migrations
  4. Atomic Updates - Single row update, no race conditions
  5. Follows Your Pattern - Matches existing items_json usage
  6. Easy Cleanup - Can reset entire wizard state with one update

  Should we update the spec?

  Want me to update the task spec
  (docs/todos/086-list-wizard-verification-workflow.md) to remove the
  list_wizard_states table and use list.wizard_state JSONB instead?

> yes update the spec 

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 200 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 1    
     addition and 1 removal
       113      - Not found (count + %)
       114    - [ ] Allow skipping enrichment for individual items
       115    - [ ] Retry button for failed enrichments
       116 -  - [ ] Background job with progress tracking (
           -  Sidekiq + Redis)
       116 +  - [ ] Background job with progress tracking (polling)
       117    
       118    #### FR-4: Step 3 - AI Validation of Matches
       119    - [ ] Run AI validation on enriched items

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 5 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 1    
     addition and 1 removal
        95      - `metadata: {rank, title, artists[], album, 
             release_year, ...}`
        96      - `verified: false`
        97      - `position: rank`
        98 -  - [ ] Show parsing progress (real-time via Action Cable or 
           -  polling)
        98 +  - [ ] Show parsing progress (polling)
        99    - [ ] Display parsed items count
       100    - [ ] Validation: Ensure list has `raw_html` or 
             `simplified_html`
       101    - [ ] Allow manual addition of items if parsing incomplete

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 100 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 41 
     additions and 12 removals
       268    
       269    ### Database Schema Changes
       270    
       271 -  #### Add Wizard State Table
       271 +  #### Add Wizard State JSONB Field to Lists
       272    
       273 -  **Table**: `list_wizard_states`
       273 +  **Migration**:
       274    
       275    ```ruby
       276 -  create_table :list_wizard_states do |t|
       277 -    t.references :list, null: false, foreign_key: true, 
           - index: true
       278 -    t.integer :current_step, null: false, default: 0
       279 -    t.jsonb :step_data, default: {}
       280 -    t.datetime :started_at
       281 -    t.datetime :completed_at
       282 -    t.timestamps
       276 +  class AddWizardStateToLists < ActiveRecord::Migration[8.0]
       277 +    def change
       278 +      add_column :lists, :wizard_state, :jsonb, default: {}
       279 +    end
       280    end
       281 +  ```
       282    
       283 -  # Steps: 0=parse, 1=enrich, 2=validate, 3=review, 4=import,
           -  5=complete
       284 -  # step_data stores arbitrary data per step (e.g., selected 
           - items for import)
       283 +  **Structure**: The `wizard_state` JSONB field stores all 
           + wizard progress and job status:
       284 +  
       285 +  ```json
       286 +  {
       287 +    "current_step": 2,
       288 +    "started_at": "2025-01-19T10:30:00Z",
       289 +    "completed_at": null,
       290 +  
       291 +    "job_status": "running",
       292 +    "job_progress": 45,
       293 +    "job_error": null,
       294 +    "job_metadata": {
       295 +      "total_items": 100,
       296 +      "processed_items": 45,
       297 +      "enriched_count": 40,
       298 +      "failed_count": 5
       299 +    },
       300 +  
       301 +    "step_data": {
       302 +      "items_to_import": [123, 456, 789]
       303 +    }
       304 +  }
       305    ```
       306    
       307 -  **Purpose**: Track wizard progress, allow resuming, store 
           - step-specific data.
       307 +  **Purpose**:
       308 +  - Track wizard progress (current step, started/completed 
           + timestamps)
       309 +  - Store background job status (for polling)
       310 +  - Store step-specific data (e.g., items queued for import)
       311 +  - Allow resuming wizard after browser close
       312 +  - No separate table needed - single JSONB field on List 
           + model
       313    
       314 +  **Job Status Values**:
       315 +  - `"idle"` - No job running
       316 +  - `"running"` - Job in progress
       317 +  - `"completed"` - Job finished successfully
       318 +  - `"failed"` - Job encountered error
       319 +  
       320    #### Add Indexes to list_items
       321    
       322    ```ruby

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 150 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 4 
     additions and 1 removal
       460      end
       461    
       462      def set_wizard_state
       463 -      @wizard_state = @list.list_wizard_state || 
           - @list.create_list_wizard_state!(started_at: Time.current)
       463 +      # Initialize wizard_state if empty
       464 +      if @list.wizard_state.blank?
       465 +        @list.reset_wizard!
       466 +      end
       467      end
       468    
       469      def wizard_step_path(step:)

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 2  
     additions and 1 removal
       388      STEPS = %w[parse enrich validate review import 
             complete].freeze
       389    
       390      def show
       391 -      redirect_to wizard_step_path(step: 
           - @wizard_state.current_step)
       391 +      current_step_name = STEPS[@list.wizard_current_step] ||
           +  "parse"
       392 +      redirect_to wizard_step_path(step: current_step_name)
       393      end
       394    
       395      def show_step

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 3  
     additions and 1 removal
       436          enqueue_import_jobs
       437        end
       438    
       439 -      @wizard_state.update!(current_step: current_index + 1)
       439 +      # Update wizard state
       440 +      new_wizard_state = 
           + @list.wizard_state.merge("current_step" => current_index + 
           + 1)
       441 +      @list.update!(wizard_state: new_wizard_state)
       442    
       443        redirect_to wizard_step_path(step: STEPS[current_index 
             + 1])
       444      end

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 13 
     additions and 2 removals
       447        current_index = STEPS.index(params[:step])
       448        return if current_index.zero?
       449    
       450 -      @wizard_state.update!(current_step: current_index - 1)
       450 +      new_wizard_state = @list.wizard_state.merge("
           +  current_step" => current_index - 1)
       451 +      @list.update!(wizard_state: new_wizard_state)
       452 +  
       453        redirect_to wizard_step_path(step: STEPS[current_index 
             - 1])
       454      end
       455    
       456      def restart
       457 -      @wizard_state.update!(current_step: 0, step_data: {}, 
           - started_at: Time.current, completed_at: nil)
       457 +      @list.reset_wizard!
       458        redirect_to wizard_step_path(step: "parse")
       459      end
       460    
       461 +    def step_status
       462 +      render json: {
       463 +        status: @list.wizard_job_status,
       464 +        progress: @list.wizard_job_progress,
       465 +        error: @list.wizard_job_error,
       466 +        metadata: @list.wizard_job_metadata
       467 +      }
       468 +    end
       469 +  
       470      private
       471    
       472      def set_list

‚óè Now let me find and update the Models section:

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 100 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 52 
     additions and 3 removals
       1115    
       1116      def perform(list_id)
       1117        list = Music::Songs::List.find(list_id)
       1118 -      items = list.list_items.unverified
       1118    
       1119 +      # Mark as running
       1120 +      list.update_wizard_job_status(
       1121 +        status: 'running',
       1122 +        progress: 0,
       1123 +        metadata: { started_at: Time.current.iso8601 }
       1124 +      )
       1125 +  
       1126 +      items = list.list_items.unverified
       1127 +      total = items.count
       1128        enriched_count = 0
       1129        opensearch_count = 0
       1130        musicbrainz_count = 0
       1131        failed_count = 0
       1132    
       1133 -      items.each do |item|
       1133 +      items.each_with_index do |item, index|
       1134          begin
       1135            result = 
              Services::Lists::Music::Songs::ItemEnricher.call(list_item:
               item)
       1136    
     ...
       1137            Rails.logger.error "WizardEnrichListItemsJob: 
              Failed to enrich item #{item.id}: #{e.message}"
       1138            failed_count += 1
       1139          end
       1140 +  
       1141 +        # Update progress every 10 items or on last item
       1142 +        if (index + 1) % 10 == 0 || index == total - 1
       1143 +          progress = ((index + 1).to_f / total * 100).round
       1144 +  
       1145 +          list.update_wizard_job_status(
       1146 +            status: 'running',
       1147 +            progress: progress,
       1148 +            metadata: {
       1149 +              total_items: total,
       1150 +              processed_items: index + 1,
       1151 +              enriched_count: enriched_count,
       1152 +              opensearch_count: opensearch_count,
       1153 +              musicbrainz_count: musicbrainz_count,
       1154 +              failed_count: failed_count
       1155 +            }
       1156 +          )
       1157 +        end
       1158        end
       1159    
       1160 -      Rails.logger.info "WizardEnrichListItemsJob: Enriched 
            - #{enriched_count}/#{items.count} items " \
       1160 +      # Mark as completed
       1161 +      list.update_wizard_job_status(
       1162 +        status: 'completed',
       1163 +        progress: 100,
       1164 +        metadata: {
       1165 +          total_items: total,
       1166 +          processed_items: total,
       1167 +          enriched_count: enriched_count,
       1168 +          opensearch_count: opensearch_count,
       1169 +          musicbrainz_count: musicbrainz_count,
       1170 +          failed_count: failed_count,
       1171 +          completed_at: Time.current.iso8601
       1172 +        }
       1173 +      )
       1174 +  
       1175 +      Rails.logger.info "WizardEnrichListItemsJob: Enriched 
            + #{enriched_count}/#{total} items " \
       1176          "(OpenSearch: #{opensearch_count}, MusicBrainz: 
              #{musicbrainz_count}, Failed: #{failed_count})"
       1177 +  
       1178 +    rescue => e
       1179 +      list.update_wizard_job_status(
       1180 +        status: 'failed',
       1181 +        error: e.message,
       1182 +        metadata: { failed_at: Time.current.iso8601 }
       1183 +      )
       1184 +      raise
       1185      end
       1186    end
       1187    ```

‚óè Now let me find and update the Models section to add the List model helper
   methods:

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 100 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 1    
     addition
       1640            # Wizard routes
       1641            resource :wizard, only: [:show], controller: 
              "list_wizard" do
       1642              get "step/:step", action: :show_step, as: :step
       1643 +            get "step/:step/status", action: :step_status, 
            + as: :step_status
       1644              post "step/:step/advance", action: 
              :advance_step, as: :advance_step
       1645              post "step/:step/back", action: :back_step, as: 
              :back_step
       1646              post "restart", action: :restart

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 46 
     additions and 27 removals
       1671    
       1672    ### Models
       1673    
       1674 -  #### Add ListWizardState Model
       1674 +  #### Add Wizard Helper Methods to List Model
       1675    
       1676 -  **Path**: `app/models/list_wizard_state.rb`
       1676 +  **Path**: `app/models/list.rb`
       1677    
       1678 -  **Generate with**:
       1679 -  ```bash
       1680 -  cd web-app
       1681 -  bin/rails generate model ListWizardState list:references 
            - current_step:integer step_data:jsonb started_at:datetime 
            - completed_at:datetime
       1682 -  ```
       1678 +  **Add these helper methods**:
       1679    
       1680 -  **Model Definition**:
       1681 -  
       1680    ```ruby
       1681 -  class ListWizardState < ApplicationRecord
       1682 -    belongs_to :list
       1681 +  class List < ApplicationRecord
       1682 +    # Existing code...
       1683    
       1684 -    validates :current_step, presence: true, numericality: {
            -  greater_than_or_equal_to: 0, less_than_or_equal_to: 5 }
       1684 +    # Wizard state helpers
       1685 +    def wizard_current_step
       1686 +      wizard_state.fetch("current_step", 0)
       1687 +    end
       1688    
       1689 -    # Steps: 0=parse, 1=enrich, 2=validate, 3=review, 
            - 4=import, 5=complete
       1690 -    STEPS = %w[parse enrich validate review import 
            - complete].freeze
       1689 +    def wizard_job_status
       1690 +      wizard_state.fetch("job_status", "idle")
       1691 +    end
       1692    
       1693 -    def step_name
       1694 -      STEPS[current_step]
       1693 +    def wizard_job_progress
       1694 +      wizard_state.fetch("job_progress", 0)
       1695      end
       1696    
       1697 -    def completed?
       1698 -      completed_at.present?
       1697 +    def wizard_job_error
       1698 +      wizard_state.fetch("job_error", nil)
       1699      end
       1700    
       1701 -    def in_progress?
       1702 -      started_at.present? && completed_at.nil?
       1701 +    def wizard_job_metadata
       1702 +      wizard_state.fetch("job_metadata", {})
       1703      end
       1704 -  end
       1705 -  ```
       1704    
       1705 -  #### Add Association to List Model
       1705 +    def wizard_in_progress?
       1706 +      wizard_state.fetch("started_at", nil).present? &&
       1707 +        wizard_state.fetch("completed_at", nil).nil?
       1708 +    end
       1709    
       1710 -  **Path**: `app/models/list.rb`
       1710 +    def update_wizard_job_status(status:, progress: nil, 
            + error: nil, metadata: {})
       1711 +      new_state = wizard_state.merge({
       1712 +        "job_status" => status,
       1713 +        "job_progress" => progress || wizard_job_progress,
       1714 +        "job_error" => error,
       1715 +        "job_metadata" => 
            + wizard_job_metadata.merge(metadata)
       1716 +      })
       1717    
       1718 -  **Add**:
       1718 +      update!(wizard_state: new_state)
       1719 +    end
       1720    
       1721 -  ```ruby
       1722 -  has_one :list_wizard_state, dependent: :destroy
       1721 +    def reset_wizard!
       1722 +      update!(wizard_state: {
       1723 +        "current_step" => 0,
       1724 +        "started_at" => Time.current.iso8601,
       1725 +        "completed_at" => nil,
       1726 +        "job_status" => "idle",
       1727 +        "job_progress" => 0,
       1728 +        "job_error" => nil,
       1729 +        "job_metadata" => {},
       1730 +        "step_data" => {}
       1731 +      })
       1732 +    end
       1733 +  end
       1734    ```
       1735    
       1736 +  **Purpose**: These helper methods provide a clean 
            + interface for reading and updating the `wizard_state` JSONB
            +  field without directly manipulating the hash structure.
       1737 +  
       1738    ## Dependencies
       1739    
       1740    ### Existing

‚óè Now let me update the Dependencies and Implementation Phases sections to
  remove references to the separate table:

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 50 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 4  
     additions and 5 removals
       1747    - Autocomplete pattern from existing modals
       1748    
       1749    ### New
       1750 -  - `list_wizard_states` table (wizard progress tracking)
       1750 +  - `lists.wizard_state` JSONB field (wizard progress and 
            + job status tracking)
       1751    - Wizard controller and views
       1752    - List item actions controller (verify, skip, edit, etc.)
       1753    - Service objects for verification
     ...
       1757    ## Implementation Phases
       1758    
       1759    ### Phase 1: Database & Models (1 day)
       1760 -  - [ ] Create `list_wizard_states` migration
       1760 +  - [ ] Create migration to add `wizard_state` JSONB column 
            + to `lists` table
       1761    - [ ] Add indexes to `list_items` (list_id + verified, 
              etc.)
       1762 -  - [ ] Add `ListWizardState` model
       1763 -  - [ ] Add association to `List` model
       1764 -  - [ ] Write model tests
       1762 +  - [ ] Add wizard helper methods to `List` model
       1763 +  - [ ] Write model tests for wizard helper methods
       1764    
       1765    ### Phase 2: Service Layer (2 days)
       1766    - [ ] Implement 
              `Services::Lists::Music::Songs::ItemEnricher`

‚óè Perfect! Now let me add a section about the polling implementation. Let me
   find where to add it:

‚óè Read(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Read 100 lines

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 82 
     additions and 20 removals
        907    
        908    ### Stimulus Controllers
        909    
        910 -  #### 1. list_wizard_controller.js
        910 +  #### 1. wizard_step_controller.js
        911    
        912 -  **Path**: `app/javascript/controllers/
            -  list_wizard_controller.js`
        912 +  **Path**: `app/javascript/controllers/
            +  wizard_step_controller.js`
        913    
        914 -  **Purpose**: Manage wizard step navigation, progress 
            - indicator
        914 +  **Purpose**: Polling for background job status and step 
            + progression
        915    
        916    ```javascript
        917    import { Controller } from "@hotwired/stimulus"
        918    
        919    export default class extends Controller {
        920 -    static targets = ["step", "progress"]
        920      static values = {
        921 -      currentStep: Number,
        922 -      totalSteps: Number
        921 +      listId: Number,
        922 +      stepName: String,
        923 +      pollInterval: { type: Number, default: 2000 } // 2 
            + seconds
        924      }
        925    
        926 +    static targets = ["progressBar", "statusText", 
            + "nextButton"]
        927 +  
        928      connect() {
        929 -      this.updateProgress()
        929 +      this.startPolling()
        930      }
        931    
        932 -    updateProgress() {
        933 -      const percent = (this.currentStepValue / 
            - this.totalStepsValue) * 100
        934 -      this.progressTarget.style.width = `${percent}%`
        932 +    disconnect() {
        933 +      this.stopPolling()
        934      }
        935    
        936 -    nextStep(event) {
        937 -      event.preventDefault()
        938 -      // Handled by controller action, just visual feedback
        939 -      this.showLoading()
        936 +    startPolling() {
        937 +      this.poll()
        938      }
        939    
        940 -    prevStep(event) {
        941 -      event.preventDefault()
        942 -      this.showLoading()
        940 +    stopPolling() {
        941 +      if (this.pollTimer) {
        942 +        clearInterval(this.pollTimer)
        943 +        this.pollTimer = null
        944 +      }
        945      }
        946    
        947 -    showLoading() {
        948 -      // Show loading spinner in Turbo Frame
        949 -      this.element.classList.add("loading")
        947 +    poll() {
        948 +      this.pollTimer = setInterval(() => {
        949 +        this.checkJobStatus()
        950 +      }, this.pollIntervalValue)
        951      }
        952 +  
        953 +    async checkJobStatus() {
        954 +      try {
        955 +        const response = await fetch(
        956 +          `/admin/music/songs/lists/${this.listIdValue}/wiza
            + rd/step/${this.stepNameValue}/status`
        957 +        )
        958 +        const data = await response.json()
        959 +  
        960 +        // Update progress bar
        961 +        this.updateProgress(data.progress, data.metadata)
        962 +  
        963 +        // If completed, enable next button and stop polling
        964 +        if (data.status === 'completed') {
        965 +          this.stopPolling()
        966 +          this.enableNextButton()
        967 +        }
        968 +  
        969 +        // If failed, show error and stop polling
        970 +        if (data.status === 'failed') {
        971 +          this.stopPolling()
        972 +          this.showError(data.error)
        973 +        }
        974 +      } catch (error) {
        975 +        console.error('Failed to check job status:', error)
        976 +        // Continue polling even on error
        977 +      }
        978 +    }
        979 +  
        980 +    updateProgress(percent, metadata) {
        981 +      if (this.hasProgressBarTarget) {
        982 +        this.progressBarTarget.style.width = `${percent}%`
        983 +        this.progressBarTarget.textContent = `${percent}%`
        984 +      }
        985 +  
        986 +      if (this.hasStatusTextTarget && metadata) {
        987 +        const processed = metadata.processed_items || 0
        988 +        const total = metadata.total_items || 0
        989 +        this.statusTextTarget.textContent = `Processing 
            + ${processed} of ${total} items...`
        990 +      }
        991 +    }
        992 +  
        993 +    enableNextButton() {
        994 +      if (this.hasNextButtonTarget) {
        995 +        this.nextButtonTarget.disabled = false
        996 +        
            + this.nextButtonTarget.classList.remove('btn-disabled')
        997 +      }
        998 +    }
        999 +  
       1000 +    showError(error) {
       1001 +      // Show error message in UI
       1002 +      const errorDiv = document.createElement('div')
       1003 +      errorDiv.className = 'alert alert-error mt-4'
       1004 +      errorDiv.innerHTML = `
       1005 +        <svg xmlns="http://www.w3.org/2000/svg" 
            + class="stroke-current shrink-0 h-6 w-6" fill="none" 
            + viewBox="0 0 24 24">
       1006 +          <path stroke-linecap="round" 
            + stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 
            + 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
       1007 +        </svg>
       1008 +        <span>${error}</span>
       1009 +      `
       1010 +      this.element.appendChild(errorDiv)
       1011 +    }
       1012    }
       1013    ```
       1014    

‚óè Perfect! Now let me update the Phase 6 section to reflect the correct
  controller name:

‚óè Update(docs/todos/086-list-wizard-verification-workflow.md)
  ‚éø ¬†Updated docs/todos/086-list-wizard-verification-workflow.md with 1    
     addition and 1 removal
       1857    - [ ] Component tests
       1858    
       1859    ### Phase 6: Stimulus Controllers (1 day)
       1860 -  - [ ] `list_wizard_controller.js`
       1860 +  - [ ] `wizard_step_controller.js` (polling for job status)
       1861    - [ ] `list_item_editor_controller.js`
       1862    - [ ] `bulk_actions_controller.js`
       1863    - [ ] `filter_controller.js`

‚óè Perfect! The spec is now updated. Let me create a quick summary document:

‚óè Write(docs/todos/086-polling-approach-summary.md)
  ‚éø ¬†Wrote 245 lines to docs/todos/086-polling-approach-summary.md         
     # Wizard Polling Approach - Summary
     ## Decision: Use Simple Database Polling (Not WebSockets/Action Cable)
     ### Why Polling is Best for This Use Case
     1. **Low Frequency Updates**: Enrichment takes 1-2 seconds per song.
     For a 100-song list, that's 2-3 minutes total. Polling every 2 seconds
     is perfectly acceptable.
     2. **Admin-Only Feature**: This wizard is used by admins/editors, not
     end-users. Not thousands of concurrent wizards.

     ‚Ä¶ +235 lines (ctrl+o to expand)

‚óè Perfect! The spec has been updated. Here's what I changed:

  Summary of Changes

  ‚úÖ Removed the separate list_wizard_states table

  - Now uses a single wizard_state JSONB field on the lists table
  - Much simpler - no joins, no new table, just one column

  ‚úÖ Updated all code examples to use JSONB approach

  - Jobs update list.update_wizard_job_status(...)
  - Controller reads @list.wizard_job_status, @list.wizard_job_progress,
  etc.
  - Helper methods on List model provide clean interface

  ‚úÖ Added polling implementation details

  - wizard_step_controller.js polls every 2 seconds
  - step_status endpoint returns JSON with job status
  - Progress bar updates, button enables when complete

  ‚úÖ Updated Implementation Phases

  - Phase 1 now says "add wizard_state JSONB column" instead of creating new
   table

  ‚úÖ Created summary document

  - /docs/todos/086-polling-approach-summary.md explains the polling
  approach and why it's better than WebSockets for this use case

  Key Benefits of This Approach

  1. Simpler Schema: Just one JSONB column, no new table
  2. No Querying Needed: Only used for display, not queries
  3. Atomic Updates: Single row update, no concurrency issues
  4. Follows Your Pattern: Matches existing items_json usage
  5. Single User: No risk of conflicts since only one person works on a list
   at a time

  The full spec is ready at
  /docs/todos/086-list-wizard-verification-workflow.md. Want me to start
  implementing Phase 1 (database migration and model helpers)?



